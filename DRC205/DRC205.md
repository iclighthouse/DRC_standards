***
DRC: 205  
Title: Swap Transaction Records Storage Standard   
Author: Avida <avida.life@hotmail.com>, Simpson <icpstaking-wei@hotmail.com>  
Status: Draft  
Category: Swap DRC  
Created: 2021-12-10
***

## Abstract

DRC205 is a standard for scalable storage of swap transaction records. It supports multi-dex storage, automatic scaling to create storage canisters (buckets), and automatic routing of query records.

![DRC205](drc205.jpg)

## Motivation

Dex's transaction records have a need to a persistent and transparent storage, and therefore require a scalable external storage solution.

The DRC205 standard consists of three parts.

* Swap transaction record data structure (TxnRecord): Defines a generic data structure that adapts to AMM and OrderBook schemas of Dex, taking into account data transparency and privacy protection.

* Scalable storage interface specification: The scalable storage mechanism is composed of a Root contract, the auto-scalable entry contract Proxy (which stores Bloom filter data) and the auto-scalable storage contract Bucket (which stores transaction record data). Proxy creates buckets according to the actual storage requirements (a new Bucket is created when one is full), and then compresses the transaction records and stores them in the Bucket. When you want to query a transaction record, you can first query the bucketId where the record is stored from the Proxy contract (using BloomFilter technology for routing, https://en.wikipedia.org/wiki/Bloom_filter ), and then query the transaction record from the specified Bucket.

* Dapp Development Kits (Motoko Module) & Guide: It is recommended that Dex developers adopt a transaction record storage specification that takes the model of "recent records cached in the current Canister + historical records persistently stored in the external Canister" and provides a query interface.


## Development Guide

https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/dev-guide.md


## Specification

**NOTES**:

- The following specifications use syntax from Candid.
- The `Sid` is the globally unique transaction record storage ID, Blob type, 28 bytes, generated by the Proxy contract.
- The `Txid` is a unique transaction record ID within a dapp, Blob type, SHOULD be 8 or 32 bytes, generated by the dapp contract. Recommended method of generating txid: [DRC205.generateTxid(_app: Principal, _caller: AccountId, _nonce: Nat)](https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/DRC205Types.mo).
    If you use Nat as txid, please convert Nat to Nat64 and then use big-endian encoding to generate 8-byte binary.
- The `AccountId` is the user's identity ID, usually a 32-byte Blob type, generated by the Dex contract. If you use types such as Principal, [Nat8], etc., you NEEDs to convert it to AccountId (Blob). If the token of the pair is of the ICRC1 standard Account type, it needs to be converted to AccountId(Blob), the `msgCaller` field in the type `TxnRecord` is filled with the trader's `owner` and the `caller` field is filled with the trader's `subaccount`.

### Transaction Record Types (TxnRecord)

This is a recommended data structure. If you use a custom data structure, you can use the `storeBytesBatch` method to meet compatibility requirements.

``` candid
type Status = variant { Failed; Pending; Completed; PartiallyCompletedAndCancelled; Cancelled; };
type TxnRecord = record {
   account: AccountId;
   caller: AccountId;
   cyclesWallet: opt CyclesWallet;
   data: opt Data;
   details: vec record {
       counterparty: Txid;
       time: Time;
       token0Value: BalanceChange;
       token1Value: BalanceChange;
     };
   fee: record { token0Fee: int; token1Fee: int; };
   filled: record { token0Value: BalanceChange; token1Value: BalanceChange; };
   index: nat;
   msgCaller: opt principal;
   nonce: Nonce;
   operation: OperationType;
   order: record { token0Value: opt BalanceChange; token1Value: opt BalanceChange; };
   orderMode: variant { AMM; OrderBook; };
   orderType: opt variant { FAK; FOK; LMT; MKT; };
   shares: ShareChange;
   status: Status;
   time: Time;
   token0: TokenType;
   token1: TokenType;
   txid: Txid;
 };
type Txid = blob;
type TokenType = variant { Cycles; Icp; Token: principal; };
type Time = int;
type Shares = nat;
type ShareChange = variant { Burn: Shares; Mint: Shares; NoChange; };
type OperationType = variant { AddLiquidity; Claim; RemoveLiquidity; Swap; };
type Nonce = nat;
type Data = blob;
type CyclesWallet = principal;
type BucketInfo = record { count: nat;cycles: nat; heap: nat; memory: nat; stableMemory: nat32; };
type Bucket = principal;
type BalanceChange = variant { CreditRecord: nat; DebitRecord: nat; NoChange; };
type AppInfo = record { count: nat; lastIndex: nat; lastTxid: Txid; };
type AppId = principal;
type AccountId = blob;
```

Types in Motoko: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/DRC205Types.mo

See development example annotations for field explanations: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo

### Generic storage interfaces (Root, Proxy和Bucket)

#### 0. DRC205Root

#### proxyList

Returns the list of Proxies and the current Proxy.  

``` candid
proxyList : () -> (record {root: principal; list: vec record {principal; Time, nat}; current: opt record {principal; Time, nat} }) query;
```

#### getTxnHash (composite_query)

Returns the hash value of the transaction record. Since there may be multiple matching fills for an order, it is possible that multiple records of a `_txid` exist, and specifying `_merge` as true means that multiple fills for the same order will be merged. If multiple order records exist, multiple hash values are returned.   
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
getTxnHash : (_app: AppId, _txid: Txid, _merge: bool) -> (vec Hex) composite_query;
```

#### getArchivedTxnBytes (composite_query)

Returns the binary value of the archived transaction record for the specified trading pair `_app` and `_txid`. If multiple records exist, multiple values are returned.       
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
getArchivedTxnBytes : (_app: AppId, _txid: Txid) -> (vec record{ vec nat8; Time }) composite_query;
```

#### getArchivedTxn (composite_query)

Returns the archived transaction record for the specified trading pair `_app` and `_txid`. If multiple records exist, multiple values are returned.        
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
getArchivedTxn : (_app: AppId, _txid: Txid) -> (vec record{ TxnRecord; Time }) composite_query;
```

#### getArchivedTxnByIndex (composite_query)

Returns an archived transaction record for the specified transaction pair `_app` and its block index `_tokenBlockIndex`.  If multiple records exist, multiple values are returned.         
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
getArchivedTxnByIndex : (_app: AppId, _tokenBlockIndex: nat) -> (vec record{ TxnRecord; Time }) composite_query;
```

#### getArchivedDexTxns (composite_query)

Returns a list of transaction records for the specified pair `_app`. The parameter `_start_desc` indicates the starting block index, in descending order. The `_length` parameter indicates the number of records to fetch at a time.        
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
getArchivedDexTxns : (_app: AppId, _start_desc: nat, _length: nat) -> (vec TxnRecord) composite_query;
```

#### getArchivedAccountTxns (composite_query)

Returns a list of transaction records for the specified `AccountId`. Because records may be stored in different Proxy and Bucket, it will lookup from the most recent Bucket in the latest Proxy, `_buckets_offset` indicates how many buckets to skip to the beginning, `_buckets_length` indicates how many buckets to lookup at a time, `_app` optionally specifies which trading pair, `_page` (one based) and `_size` paginate the queried dataset.         
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
getArchivedAccountTxns : (_buckets_offset: opt nat, _buckets_length: nat, _account: AccountId, _app: opt AppId, _page: opt nat32, _size: opt nat32)
 -> (record {data: vec record{ principal; vec record{ TxnRecord; Time } }; totalPage: nat; total: nat});
```


#### 1. DRC205Proxy

DRC205Proxy is a proxy canister for transaction record storage that automatically creates and manages Bucket canisters.

#### standard

Returns standard name.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
standard: () -> (text) query;
```

#### version

Returns version value.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
version: () -> (nat8) query;
```

#### fee

Returns the fee (cycles) to be paid for storing a transaction record. Pay once for permanent storage.

``` candid
fee: () -> (cycles: nat) query;
```

#### storeBatch

Batch storage of transaction records, allowing storage at intervals of more than 20 seconds. Calling this method requires adding cycles as a cost (fee is queried via the `fee()` method), and batch storage of n messages requires paying n*fee Cycles.

``` candid
storeBatch: (_txns: vec TxnRecord) -> ();
```

#### storeBytesBatch

Batch storage of binary records, allowing storage at intervals of more than 20 seconds. Calling this method requires adding cycles as a cost (fee is queried via the `fee()` method), and batch storage of n messages requires paying n*fee Cycles.

``` candid
storeBytesBatch: (_txns: vec record { Txid; vec nat8 }) -> ();
```

#### getLastTxns

Returns the latest stored transaction records.

``` candid
getLastTxns: () -> (vec record { index: nat; app: AppId; indexInApp: nat; txid: Txid; }) query;
```

#### location

Returns the Bucket where the transaction record for the given _app and _arg(txid, index or accountId) is located. returns the empty array if it does not exist; if the return value contains multiple values, it means that the transaction record may be stored in one of the Buckets and can be traversed to find it.

``` candid
location: (_app: AppId, _arg: variant{ txid: Txid; index: nat; account: AccountId}, _version: opt nat8) -> (vec Bucket) query;
```

#### generateTxid

Generates txid based on the given app `_app`, accountId `_caller`, nonce `_nonce` values.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
generateTxid: (_app: AppId, _caller: AccountId, _nonce: nat) -> (Txid) query;
```

#### stats

Returns statistics.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
stats: () -> (record { bucketCount: nat; errCount: nat; storeErrPool: nat; tokenCount: nat; txnCount: nat; }) query;
```

#### bucketListSorted

Returns bucket list.  
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
bucketListSorted : () -> (vec record {Bucket, Time, nat}) query;
```


#### 2. DRC205Bucket

DRC205Bucket is used to store transaction record data and to implement the public query interface.

#### txn

Returns the transaction record for the specified `_app` and `_txid`.

``` candid
txn: (_app: AppId, _txid: Txid) -> (opt record { TxnRecord; Time; }) query;
```

#### txnHistory

Returns the transaction record for the specified `_app` and `_txid`. Returns an array containing the history of all modifications.  

``` candid
txnHistory: (_app: AppId, _txid: Txid) -> (vec record { TxnRecord; Time; }) query;
```

#### txnBytes

Returns the binary data of the transaction record for the specified `_app` and `_txid`. 

``` candid
txnBytes: (_app: AppId, _txid: Txid) -> (opt record { vec nat8; Time; }) query;
```

#### txnBytesHistory

Returns the binary data of the transaction record for the specified `_app` and `_txid`. Returns an array containing the history of all modifications.  

``` candid
txnBytesHistory: (_app: AppId, _txid: Txid) -> (vec record { vec nat8; Time; }) query;
```

#### txnByIndex

Returns a set of transaction history records for the specified `_app` and `_blockIndex`.     
OPTIONAL - This method can be used to improve usability, but the method may not exist.

``` candid
txnByIndex: (_app: AppId, _blockIndex: nat) -> (vec record{TxnRecord; Time}) query;
```

#### txnByAccountId

Returns a set of transaction records for the specified `_accountId` and `_app`. Note: _page starts from 1.     
OPTIONAL - This method can be used to improve usability, but the method may not exist.

``` candid
txnByAccountId: (_accountId: AccountId, _app: opt AppId, _page: opt nat32, _size: opt nat32) -> (record{data: vec record{AppId; vec record{TxnRecord; Time}}; totalPage: nat; total: nat}) query;
```

#### txnHash

Calculates all Hash values of the specified transaction record history. If `_merge` is specified as true means that multiple trades (e.g. multiple fills) of the same transaction will be merged into one transaction and then the Hash value will be calculated.     
OPTIONAL - This method can be used to improve usability, but the method may not be present.
``` candid
txnHash: (AppId, Txid, _merge: bool) -> (vec Hex) query;
```

#### bucketInfo 

Returns information about the current bucket.   
OPTIONAL - This method can be used to improve usability, but the method may not be present.

``` candid
bucketInfo: () -> (BucketInfo) query;
```

#### 3. Trading Pair Interface (Implementation)

Dex developers should implement the following interface in trading pair to facilitate querying transaction records.

#### drc205_canisterId

Returns the Root's canister-id。

``` candid
drc205_canisterId: () -> (principal) query;
```

#### drc205_events

Returns the transaction records for the specified account `Address`. If Address is not specified means to query all latest transaction records. Address is of type Text, is Principal or AccountId, e.g. "tqnrp-pjc3b-jzsc2-fg5tr-...-ts5ax-lbebt-uae", "1af2d0af449ab5a13e30...ee1f99a9ece5ceaf8fe4".

``` candid
drc205_events: (opt Address) -> (vec TxnRecord) query;
```

#### drc205_events_filter

Return the specified account `Address`, and filter the transaction records from start time `Time` to end time `Time` (nanoseconds), if not specified, then return the global recent transaction records. Address is of type Text, is Principal or AccountId, e.g. "tqnrp-pjc3b-jzsc2-fg5tr-...-ts5ax-lbebt-uae", "1af2d0af449ab5a13e30...ee1f99a9ece5ceaf8fe4".

``` candid
drc205_events_filter: (opt Address, opt Time, opt Time) -> (vec TxnRecord, bool) query;
```

#### drc205_txn

Returns the transaction records in the token canister cache for the specified `Txid`. To query the transaction records stored in DRC205, use the [Developer's Guide](https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/dev-guide.md).

``` candid
drc205_txn: (Txid) -> (opt TxnRecord) query;
```

#### drc205_txn2

Returns the transaction record for the specified `Txid`. This is a composite query that looks up records from archived data if they are not in the cache.

``` candid
drc205_txn2 : (_txid: Txid) -> (opt TxnRecord) composite_query
```

#### drc205_archived_txns

Returns a list of archived transaction records. This is a composite query, starting from the descending order of the specified BlockIndex `_start_desc`.

``` candid
drc205_archived_txns : (_start_desc: nat, _length: nat) -> (vec TxnRecord) composite_query;
```

#### drc205_archived_account_txns

Returns a list of archived transaction records for the specified `AccountId`. This is a composite query, which can be queried from which buckets by specifying `_buckets_offset` and `_buckets_length`, and buckets are sorted in descending order.

``` candid
drc205_archived_account_txns : (_buckets_offset: opt nat, _buckets_length: nat, _account: AccountId, _page: opt nat32, _size: opt nat32) -> ({data: vec record{principal; vec record{TxnRecord; Time}}; totalPage: nat; total: nat}) composite_query;
```


### Development Kits (Motoko Module) & Guides

#### DRC205 Module

import DRC205 "lib/DRC205";

#### root

Returns DRC205Root actor.

``` candid
root: () -> DRC205Types.Root;
```

#### proxy

Returns DRC205Proxy actor.

``` candid
proxy: () -> DRC205Types.Proxy;
```

#### drc205CanisterId

Returns the Root canister-id。 

``` candid
drc205CanisterId: () -> principal;
```

#### getProxyList

Returns the list of proxies.

``` candid
getProxyList: () -> vec {principal; Time; nat};
```

#### config

Configure the properties EN_DEBUG, MAX_CACHE_TIME, MAX_CACHE_NUMBER_PER, MAX_STORAGE_TRIES, etc.

``` candid
config: (_config: Config) -> bool;
```

#### getConfig

Returns the configuration information. 

``` candid
getConfig: () -> Setting;
```

#### generateTxid

Generates the txid. 

``` candid
generateTxid : (_app: principal, _caller: AccountId, _nonce: nat) -> Txid;
```

#### get

Finds the record with the specified `_txid` from the current canister cache, or returns null if it does not exist. 

``` candid
get : (_txid: Txid) -> opt TxnRecord;
```

#### put

Caches a record `_txn`.

``` candid
put : (_txn: TxnRecord) -> ();
```

#### store

Asynchronously stores a record into the extended Canister. 

``` candid
store : () -> ();
```

#### get2

Finds the record with the specified `_txid` from the current canister cache, or finds the record from the external canister if it does not exist. This is an update method.  

``` candid
get2 : (_txid: Txid) -> opt TxnRecord;
```

#### getLastTxns

Returns a list of latest records txid for user `_account`.  

``` candid
getLastTxns : (_account: opt AccountId) -> vec Txid;
```

#### getEvents

Returns a list of details of the records for account `_account`.

``` candid
getEvents : (_account: opt AccountId, _startTime: opt Time, _endTime: opt Time) -> (vec TxnRecord, bool);
```

#### getData

Returns the data of the drc205 object, which is only used for data backup during upgrade.  

``` candid
getData : () -> DataTemp;
```

#### setData

Sets the data of the drc205 object, which is used only for upgrades.  

``` candid
setData : (_data: DataTemp) -> ();
```

#### Rust Developer's Guide

DRC205 Root (Main): lw5dr-uiaaa-aaaak-ae2za-cai   
DRC205 Root (Test): lr4ff-zqaaa-aaaak-ae2zq-cai  

Refer to the Candid file interface at

https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/DRC205Root.did  
https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/DRC205Proxy.did  
https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/DRC205Bucket.did  

Please call the storeBatch or storeBytesBatch method for batch storage, paying attention to adding Cycles and the time interval between calls.


#### Motoko Developer's Guide 

DRC205 Root (Main): lw5dr-uiaaa-aaaak-ae2za-cai   
DRC205 Root (Test): lr4ff-zqaaa-aaaak-ae2zq-cai  

Motoko development example: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo

**Step1** Importing module files

Puts the folder https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/ into your project directory, and import modules into your code.
``` motoko
import Array "mo:base/Array";
import Principal "mo:base/Principal";
import Time "mo:base/Time";
import DRC205 "lib/DRC205";
``` 

**Step2** Writing codes

Declare private global variables, e.g.
``` motoko
// Set EN_DEBUG=false in the production environment.
private var drc205 = DRC205.DRC205({EN_DEBUG = true; MAX_CACHE_TIME = 3 * 30 * 24 * 3600 * 1000000000; MAX_CACHE_NUMBER_PER = 100; MAX_STORAGE_TRIES = 2; });
``` 

Generates Txid and TxnRecord, execute drc205.put(txn) to store the record into the cache, and execute drc205.store() to store the record into the DRC205 storage canister, e.g.
``` motoko
    public shared(msg) func test(_n: Nat) : async DRC205.Txid{
        let caller = drc205.getAccountId(msg.caller, null);
        let txid = drc205.generateTxid(Principal.fromActor(this), caller, _n);
        var txn: DRC205.TxnRecord = {
            txid = txid; // Transaction id
            msgCaller = null; // Caller principal
            caller = caller; // Caller account (Blob)
            operation = #Swap; // { #AddLiquidity; #RemoveLiquidity; #Claim; #Swap; }
            account = caller; // Swap user account (Blob)
            cyclesWallet = null; // Cycles wallet principal, used only for one of trading pair tokens is cycles.
            token0 = #Token(Principal.fromText("ueghb-uqaaa-aaaak-aaioa-cai")); // Trading pair { #Cycles; #Icp; #Token: Principal; }
            token1 = #Token(Principal.fromText("udhbv-ziaaa-aaaak-aaioq-cai")); // Trading pair { #Cycles; #Icp; #Token: Principal; }
            token0Value = #DebitRecord(10000000000); // #DebitRecord indicates the amount of token0 spent for swapping.
            token1Value = #CreditRecord(20000000000); // #CreditRecord indicates the amount of token1 received from swapping.
            fee = {token0Fee = 0; token1Fee = 20000; }; // fee
            shares = #NoChange; // Liquidity shares change of user. { #Mint: Nat; #Burn: Nat; #NoChange; }
            time = Time.now(); // Timestamp (nanoseconds).
            index = _n;  // Global Index
            nonce = _n;  // Nonce of user
            orderType = #AMM; // Order Type  { #AMM; #OrderBook; }
            details = []; // Counterparty order list, for orderbook mode only.
            data = null; // Attached data (Blob)
        };
        drc205.put(txn); // Put txn to the current canister cache.
        let store = /*await*/ drc205.store(); // Store in the DRC205 scalable bucket.
        return txid;
    };
``` 

**Step3** Writing queries and upgrade functions

It is recommended to implement the following methods in your dapp. (Convenient ic.house explorer query records)

* drc205_getConfig : () -> (Setting) query
* drc205_canisterId : () -> (principal) query
* drc205_dexInfo : () -> (DexInfo) query
* drc205_events : (_account: opt DRC205.Address) -> (vec TxnRecord) query
* drc205_events_filter: (opt Address, opt Time, opt Time) -> (vec TxnRecord, bool) query;
* drc205_txn : (_txid: Txid) -> (opt TxnRecord) query
* drc205_txn2 : (_txid: Txid) -> (opt TxnRecord) composite_query
* drc205_archived_txns : (_start_desc: nat, _length: nat) -> (vec TxnRecord) composite_query;
* drc205_archived_account_txns : (_buckets_offset: opt nat, _buckets_length: nat, _account: AccountId, _page: opt nat32, _size: opt nat32) -> ({data: vec record{principal; vec record{TxnRecord; Time}}; totalPage: nat; total: nat}) composite_query;

E.g.
https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo


## Examples

#### Implementations

- Storage Canister: https://github.com/iclighthouse/DRC_standards/tree/main/DRC205/examples/IClighthouse   

- Motoko Module: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/lib/DRC205.mo 

- Development Example: https://github.com/iclighthouse/DRC_standards/blob/main/DRC205/examples/ICLighthouse/Example/Example.mo   